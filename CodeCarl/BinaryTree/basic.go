package binarytree

/*
1、二叉树理论基础
Day:2022-6-3
Update: 2023-1-14

满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，
	并且度为0的结点在同一层上，则这棵二叉树为满二叉树。
	深度为k，有2^k-1个节点.

完全二叉树：除了最底层节点可能没填满外，其余每层节点数都达到最大值，
	并且最下面一层的节点都集中在该层最左边的若干位置。
	若最底层为第 h 层，则该层包含 1~ 2^(h-1)  个节点。

优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。
堆分：大顶堆和小顶堆。

二叉搜索树：二叉搜索树是有数值的，二叉搜索树是一个有序树。
	若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
	若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
	它的左、右子树也分别为二叉排序树。

平衡二叉搜索树：
	它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，
	并且左右两个子树都是一棵平衡二叉树。
C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，
	所以map、set的增删操作时间时间复杂度是logn.
	注意这里没有说unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表。
提醒：对于自己熟悉的编程语言写算法，一定要知道常用的容器底层都是如何实现的，最基本的就是map、set等等，
	否则自己写的代码，自己对其性能分析都分析不清楚！

二叉树的存储方式：链式存储，顺序存储。
	链式存储方式就用指针， 顺序存储的方式就是用数组。
	用数组来存储二叉树如何遍历的呢？
		如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。

二叉树的遍历方式：
	二叉树主要有两种遍历方式：
		深度优先遍历：先往深走，遇到叶子节点再往回走。
		广度优先遍历：一层一层的去遍历。
	这两种遍历是图论中最基本的两种遍历方式。

从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：
	深度优先遍历：（这里前中后，其实指的就是中间节点的遍历顺序，只要记住前中后序指的就是中间节点的位置就可以了。）
		前序遍历（递归法，迭代法）
		中序遍历（递归法，迭代法）
		后序遍历（递归法，迭代法）
	广度优先遍历：
		层次遍历（迭代法）

做二叉树相关题目，经常会使用递归的方式来实现深度优先遍历。
栈其实就是递归的一种实现结构，
	也就说前中后序遍历的逻辑其实都是可以借助栈使用非递归的方式来实现的。

广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的。
	因为需要先进先出的结构，才能一层一层的来遍历二叉树。
*/

/*
2. 递归遍历的理论知识
每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！
- 确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数，
	并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
- 确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，
	就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
- 确定单层递归的逻辑： 确定每一层递归需要处理的信息。
	在这里也就会重复调用自己来实现递归的过程。
*/

/*
3. 迭代深度优先遍历的理论知识
用栈实现了二叉树前后中序的迭代遍历（非递归）。
代法实现的先中后序，其实风格也不是那么统一，除了先序和后序，有关联，
	中序完全就是另一个风格了，一会用栈遍历，一会又用指针来遍历。
(统一风格的迭代法并不好理解，而且想在面试直接写出来还有难度的。
所以大家根据自己的个人喜好，对于二叉树的前中后序遍历，
选择一种自己容易理解的递归和迭代法。)
*/
type TreeNode struct {
	Val   int
	Left  *TreeNode
	Right *TreeNode
}
