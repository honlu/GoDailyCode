## 图论基本知识
图论的根源在深度优先搜索和广度优先搜索，在前面的二叉树和回溯算法中已经探索过深度优先搜索和广度优先搜索。
二叉树的遍历是深搜和广搜在二叉树结构上的应用。
回溯算法是深搜，利用了其回溯的过程。
图论是深搜和广搜在图上的遍历，图的存储方式一般是邻接表和邻接矩阵。

### 回顾搜索的理论基础
- DFS深搜与BFS广搜的区别
   1. DFS是先一个方向搜，一直走，直到没有路可以走了，再换方向（换方向的过程就涉及回溯）。
   2. BFS是先把本节点所连接的所有节点遍历一遍（各个方向都走一下），走到下一个节点的时候，再把连接节点的所有节点遍历一遍。搜索方向就是广度、四面八方的搜索过程。
   
### 深度优先搜索   
- DFS的关键两点：
  - 搜索方向，是认准一个方向搜，直到碰壁之后再换方向
  - 换方向是撤销原路径，改为节点链接的下一个路径，回溯的过程。

- DFS的代码框架
  1. DFS搜索可一个方向，并需要回溯，所以用递归的方法实现最方便。【有递归的地方就有回溯】 
   ```go
   /*
   三部曲：
   1. 确定递归函数，参数。
   2. 确定终止条件。
   3. 处理目标搜索节点出发的路径。 

   注意：
   1. 一般情况，深搜需要 二维数组数组结构保存所有路径，需要一维数组保存单一路径，这种保存结果的数组，我们可以定义一个全局变量，避免让我们的函数参数过多。
   2. 终止条件很重要，很多同学写dfs的时候，之所以容易死循环，栈溢出等等这些问题，都是因为终止条件没有想清楚。

   */
   var path []int  // 起点到终点的路径
   var res [][]int // 保存符合条件的所有路径
   var dfs func(图，目前搜索的节点){
      if (终止条件){
        存放结果
        return
      }
      for (选择;本节点所连接的其他节点){
        处理节点
        dfs(图，选择的节点);// 递归
        回溯，撤销处理结果
      }
   }
   
   ```


### 广度优先搜索
广度优先搜索适合于解决两个点之间的最短路径问题。因为广度优先搜索是从七点出发，以起始点为中心一圈一圈进行搜索，一旦遇到终点，记录之前走过的节点就是一条最短路。
也有一些问题广搜和深搜都可以解决，例如岛屿问题。【这类问题特征就是不涉及具体的遍历问题，只要能把相邻且相同属性的节点标记上就行。】

- 代码框架：
  1. 一圈圈的搜索过程是怎么做到的，是放在什么容器里，才能这样去遍历呢？【队列，栈、数组都可以，go中可以使用切片。】
  2. 用队列的话，就是保证每一圈都是一个方向去转，例如统一顺时针或者逆时针。因为队列是先进先出，加入元素和弹出元素的顺序是没有改变的。
  3. 如果用栈的话，就是第一圈顺时针遍历，第二圈逆时针遍历，第三圈有顺时针遍历。因为栈是先进后出，加入元素和弹出元素的顺序改变了。
  4. 那么广搜需要注意 转圈搜索的顺序吗？ 不需要！所以用队列，还是用栈都是可以的，但大家都习惯用队列了，所以下面的讲解用我也用队列来讲，只不过要给大家说清楚，并不是非要用队列，用栈也可以。

```go
// 方向：上、下、左、右
direct:=[][]int{
        {-1,0},{1,0},{0,-1},{0,1}
    }
m, n := len(grid), len(grid[0])
visited := make([][]bool, m)
for i := range visited{
    visited[i] = make([]bool, n)
}
// grid 是地图，也就是一个二维数组
// visited标记访问过的节点，不要重复访问
// x,y 表示开始搜索节点的下标
func BFS(grid [][]byte, visited [][]bool,x, y int){
  var queue [][2]int // 定义队列
  queue = append(queue,[2]int{x,y})// 起始节点加入队列
  visited[x][y] = true// 只要加入队列，立刻标记为访问过的节点
  for len(queue) != 0{ // // 开始遍历队列里的元素
     curX,curY := queue[0][0], queue[0][1] // 当前节点坐标
     queue = queue[1:] // 从队列取元素
     for i := 0; i < 4; i++{ // 开始当前节点的四个方向上下左右遍历
        nextX := curX + direct[i][0]
        nextY := curY + direct[i][1]
        if (nextX < 0 || nextX >= m || nextY < 0 || nextY >= n) {
          continue  // 坐标越界了，直接跳过
        }
        if !visited[nextx][nexty]{ // 如果节点没被访问过
            queue = append(queue,[2]int{nextX, nextY})  // 队列添加该节点为下一轮要遍历的节点
            visited[nextx][nexty] = true // 只要加入队列立刻标记，避免重复访问
        }
       
     }
  }
}

```