/*
887. 鸡蛋掉落
2023-1-1
link: https://leetcode.cn/problems/super-egg-drop/
question:
	给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑。
	已知存在楼层 f ，满足 0 <= f <= n ，任何从 高于 f 的楼层落下的鸡蛋都会碎， 从 f 楼层或比它低的楼层落下的鸡蛋都不会破。
	每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1 <= x <= n）。
	如果鸡蛋碎了，你就不能再次使用它。
	如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 重复使用 这枚鸡蛋。
	请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？
answer:
	如果不限制鸡蛋个数的话，可以二分思路判断f的数，进而显然可以得到最少尝试的次数，
	但问题是，现在给你了鸡蛋个数的限制 K，直接使用二分思路就不行了。

	参考其他答案：https://leetcode.cn/problems/super-egg-drop/solution/ji-dan-diao-luo-by-leetcode-solution-2/
	方法三：数学法，一种没见过就不太可能想出来，很容易忘记的方法.
	反过来想这个问题：如果我们可以做 t 次操作，而且有 k 个鸡蛋，
	那么我们能找到答案的最高的 n 是多少？我们设 f(t, k) 为在上述条件下的 n。
	如果我们求出了所有的 f(t, k), 那么只需要找出最小的满足 f(t, k)≥n 的 t。

	动态规划：
		1. 确定dp数组以及下标的含义：
			dp 数组的定义：dp[i][j]
			表示: 当前有 i 个鸡蛋，可以尝试扔 j 次鸡蛋，这个条件下最坏情况下最多能确切测试一栋 dp[i][j] 层的楼
		2. 确定递推公式
			如果鸡蛋没有碎，那么对应的是 dp[t−1][k]，也就是说在这一层的上方可以有dp[t−1][k] 层；
			如果鸡蛋碎了，那么对应的是dp[t−1][k−1]，也就是说在这一层的下方可以有dp[t−1][k−1] 层。
			因此我们就可以写出状态转移方程：
			dp[i][j+1] = dp[i][j] + dp[j-1][j] + 1
		3. dp数组如何初始化
		4. 确定遍历顺序
		5. 举例推导dp数组
*/
func superEggDrop(k int, n int) int {
	// dp数组定义和初始化：m最多不会超过n次（线性扫描）
	dp := make([][]int, k+1)
	for i := 0; i < k+1; i++ {
		dp[i] = make([]int, n+1)
	}
	// go上面默认会把数组初始化都为0
	// 遍历+递推公式更新
	j := 0
	for ; dp[k][j] < n; j++ {
		for i := 1; i < k+1; i++ {
			dp[i][j+1] = dp[i][j] + dp[i-1][j] + 1
		}
	}
	return m
}