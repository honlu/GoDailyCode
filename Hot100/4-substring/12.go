package hot100

/*
12-最小覆盖子串
给你一个字符串 S、一个字符串 T，求 S 中包含 T 所有字符的最小子串。
如果 S 中不存在包含 T 所有字符的子串，则返回空字符串 ""。
如果 S 中存在包含 T 所有字符的子串，我们保证它是唯一的答案。
注意：如果 S 中存在这样的子串，我们保证它是唯一的答案。
示例：
输入：S = "ADOBECODEBANC", T = "ABC"
输出："BANC"
说明：
- A、B、C 三个字符都必须包含在子串中，且数量要相等。
- 如果 S 中存在这样的子串，我们保证它是唯一的答案。
思路：

 1. **边界检查**：
    检查输入字符串 `s` 和 `t` 是否为空。如果任意一个为空，直接返回空字符串，因为无法找到满足条件的子串。

 2. **统计目标字符频率**：
    使用一个哈希表（`tMap`）统计字符串 `t` 中每个字符的出现次数。这是为了记录目标子串需要包含的字符及其数量。

3. **初始化滑动窗口和变量**：

  - 定义左右指针 `left` 和 `right`，表示滑动窗口的边界。

  - 初始化最小子串长度 `minLen` 为一个较大值（`len(s) + 1`），以及结果字符串 `minStr` 为空。

  - 统计 `t` 中不同字符的种类数（`count`），用于判断当前窗口是否满足条件。

    4. **扩展右边界**：
    不断移动右指针 `right`，将字符加入窗口。如果该字符在 `tMap` 中，更新其频率，并在频率变为 0 时减少 `count`。

    5. **收缩左边界**：
    当窗口包含了 `t` 中所有字符（`count == 0`）时，尝试收缩窗口：

  - 检查当前窗口长度是否比之前的最小长度更短，如果是，则更新最小长度和结果字符串。

  - 移动左指针 `left`，将窗口左边的字符移出。如果移出的字符在 `tMap` 中，更新其频率，并在频率大于 0 时增加 `count`。

    6. **继续扩展窗口**：
    重复扩展右边界和收缩左边界的过程，直到右指针遍历完整个字符串 `s`。

    7. **返回结果**：
    返回记录的最小子串 `minStr`，如果没有找到满足条件的子串，则返回空字符串。

这段代码的核心思想是通过滑动窗口动态调整窗口大小，确保窗口始终包含 `t` 中的所有字符，同时尽可能缩小窗口以找到最短的子串。
*/
func minWindow(s string, t string) string {
	if len(s) == 0 || len(t) == 0 {
		return ""
	}
	// 统计t中每个字符的数量
	tMap := make(map[byte]int)
	for i := 0; i < len(t); i++ {
		tMap[t[i]]++
	}
	// 滑动窗口
	left, right := 0, 0
	minLen := len(s) + 1
	minStr := ""
	count := len(tMap) // 统计t中不同字符的数量
	for right < len(s) {
		if _, ok := tMap[s[right]]; ok {
			tMap[s[right]]--
			if tMap[s[right]] == 0 {
				count--
			}
		}
		right++
		// 当窗口包含了t中所有的字符时，开始收缩窗口
		for count == 0 { // 说明当前窗口包含了t中所有的字符
			if right-left < minLen {
				minLen = right - left
				minStr = s[left:right]
			}
			// 将左指针向右移动，直到窗口不满足要求为止
			if _, ok := tMap[s[left]]; ok {
				tMap[s[left]]++
				if tMap[s[left]] > 0 {
					count++
				}
			}
			left++
		}
	}
	return minStr
}
